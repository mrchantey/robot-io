#pragma once

#include "nn.h"

/**
 * The size of sliding window, must be power of 2 (change this if you
 * want to use other window size, for example: 2 or 4)
 */
#ifdef CONF_W_BITS
#define W_BITS CONF_W_BITS
#else
#define W_BITS 4
#endif

/**
 * Basic mask used to generate mask array (you need to change this if
 * you want to change window size)
 * For example: if W_BITS is 2, BASIC_MASK must be 0x03;
 *              if W_BITS is 4, BASIC_MASK must be 0x0f
 *              if W_BITS is 8, BASIC_MASK must be 0xff
 */
//#define BASIC_MASK 0x0f
#define BASIC_MASK ((1 << W_BITS) - 1)

/**
 * Number of windows in one digit, NUM_MASKS = NN_DIGIT_BITS/W_BITS
 */
#define NUM_MASKS (NN_DIGIT_BITS / W_BITS)

/**
 * Number of points for precomputed points, NN_POINTS = 2^W_BITS - 1
 */
#define NUM_POINTS ((1 << W_BITS) - 1)

/**
 * The data structure define the elliptic curve.
 */
typedef struct ecurve
{
    /** curve's coefficients */
    NN_DIGIT a[NUMWORDS];
    NN_DIGIT b[NUMWORDS];

    /** whether a is -3 */
    char a_minus3;

    /** whether a is zero */
    char a_zero;

} ecurve_t;

/**
 * The data structure that defines a point of the elliptic curve.
 */
typedef struct point
{
    /** point's X coordinate. */
    NN_DIGIT x[NUMWORDS];
    /** point's X coordinate. */
    NN_DIGIT y[NUMWORDS];
} point_t;

/**
 * All the parameters needed for elliptic curve operation.
 */
typedef struct curve_params
{
    /** prime modulus */
    NN_DIGIT p[NUMWORDS];

    /** Omega, p = 2^m -omega */
    NN_DIGIT omega[NUMWORDS];

    /** curve over which ECC will be performed. */
    ecurve_t E;

    /** The base point, a point on E of order r */
    point_t G;

    /** A positive, prime integer dividing the number of points on E */
    NN_DIGIT r[NUMWORDS];

    // a positive prime integer, s.t. k = #E/r
    //    NN_DIGIT k[NUMWORDS];
} curve_params_t;

/**
 * \brief             Initialize parameters and basepoint array for
 *                    sliding window method. This function should be called first
 *                    before using other functions.
 */
void ecc_init();

/**
 * \brief             Provide order of curve for the modules which need to know
 */
void ecc_get_order(NN_DIGIT *order);

/**
 * \brief             Point addition, P0 = P1 + P2
 */
void ecc_add(point_t *P0, point_t *P1, point_t *P2);

/**
 * \brief             Point addition, (P0,Z0) = (P1,Z1) + (P2,Z2)
 *                    using projective coordinates system.
 *                    P0, P1, P2 can be same pointer.
 */
void ecc_add_proj(point_t *P0, NN_DIGIT *Z0, point_t *P1, NN_DIGIT *Z1, point_t *P2, NN_DIGIT *Z2);

/**
 * \brief             Point doubleing, (P0,Z0) = 2*(P1,Z1)
 *                    using projective coordinates system.
 *                    P0 and P1 can be same pointer
 */
void ecc_dbl_proj(point_t *P0, NN_DIGIT *Z0, point_t *P1, NN_DIGIT *Z1);

/**
 * \brief             Scalar point multiplication P0 = n * P1
 *                    P0 and P1 can not be same pointer
 */
void ecc_mul(point_t *P0, point_t *P1, NN_DIGIT *n);

/**
 * \brief             Precompute the points for sliding window method
 */
void ecc_win_precompute(point_t *baseP, point_t *pointArray);

/**
 * \brief             Scalr point multiplication using slide window method
 *                    P0 = n * Point, this Point may not be the base point of curve
 *                    pointArray is constructed by call win_precompute(Point, pointArray)
 */
void ecc_win_mul(point_t *P0, NN_DIGIT *n, point_t *pointArray);

/**
 * \brief             m repeated point doublings (Algorithm 3.23 in "Guide to ECC")
 */
void ecc_m_dbl_projective(point_t *P0, NN_DIGIT *Z0, uint8_t m);

/**
 * \brief             Scalar point multiplication on basepoint, P0 = n * basepoint
 *                    using window method.
 *                    pointArray is array of basepoint,
 *                    pointArray[0] = basepoint, pointArray[1] = 2*basepoint ...
 */
void ecc_win_mul_base(point_t *P0, NN_DIGIT *n);

/**
 * \brief             Get base point
 */
point_t *ecc_get_base_p();

/**
 * \brief             Get the parameters of specific curve.
 */
void get_curve_param(curve_params_t *para);

/**
 * \brief             Get the current curve parameters.
 */
curve_params_t *ecc_get_param(void);

/**
 * \brief             Compute a public key from a secret
 */
void ecc_gen_pub_key(NN_DIGIT *priv_key, point_t *pub);

/**
 * \brief             Compute a private key (secret)
 */
void ecc_gen_private_key(NN_DIGIT *PrivateKey);
// AUTOGENERATED, DO NOT EDIT. See CONTRIBUTING.md for instructions.
/**
 * \addtogroup ecc
 *
 * @{
 */

/**
 * \file
 * Source file for the Elliptic Curve point arithmetic functions.
 * \author
 * Kasun Hewage <kasun.ch@gmail.com>
 *
 */
// #include "ecc.h"
#include "prng.h"

#define TRUE 1
#define FALSE 0

/**
 * Enable mixed projective coordinate addition.
 */
#define ADD_MIX
/**
 * Enable repeated point doubling.
 */
#define REPEAT_DOUBLE

/*
 * parameters for ECC operations
 */
static curve_params_t param;
/*
 * precomputed array for base point
 */
static point_t pBaseArray[NUM_POINTS];
/*
 * masks for sliding window method
 */
static NN_DIGIT mask[NUM_MASKS];

/**
 * \brief             Test whether the ith bit in a is one
 */
static NN_DIGIT
b_testbit(NN_DIGIT *a, int16_t i)
{

    return (*(a + (i / NN_DIGIT_BITS)) & ((NN_DIGIT)1 << (i % NN_DIGIT_BITS)));
}
/*---------------------------------------------------------------------------*/
/**
 * \brief             Set P0's x and y to zero
 */
static void
p_clear(point_t *P0)
{
    NN_AssignZero(P0->x, NUMWORDS);
    NN_AssignZero(P0->y, NUMWORDS);
}
/*---------------------------------------------------------------------------*/
/**
 * \brief             P0 = P1
 */
static void
p_copy(point_t *P0, point_t *P1)
{
    NN_Assign(P0->x, P1->x, NUMWORDS);
    NN_Assign(P0->y, P1->y, NUMWORDS);
}
/*---------------------------------------------------------------------------*/
/**
 * \brief             Test whether x and y of P0 is all zero
 */
static int
p_iszero(point_t *P0)
{
    char result = FALSE;

    if (NN_Zero(P0->x, NUMWORDS))
    {
        if (NN_Zero(P0->y, NUMWORDS))
        {
            result = TRUE;
        }
    }
    return result;
}
/*---------------------------------------------------------------------------*/
/**
 * \brief             Test whether points P1 and P2 are equal
 */
static int
p_equal(point_t *P1, point_t *P2)
{
    if (NN_Equal(P1->x, P2->x, NUMWORDS))
    {
        if (NN_Equal(P1->y, P2->y, NUMWORDS))
        {
            return TRUE;
        }
    }
    return FALSE;
}
/*---------------------------------------------------------------------------*/
/**
 * \brief             Test whether Z is one
 */
static int
Z_is_one(NN_DIGIT *Z)
{
    uint8_t i;

    for (i = 1; i < NUMWORDS; i++)
    {
        if (Z[i])
        {
            return FALSE;
        }
    }
    if (Z[0] == 1)
    {
        return TRUE;
    }

    return FALSE;
}
/*---------------------------------------------------------------------------*/

static void
c_add_mix(point_t *P0, NN_DIGIT *Z0, point_t *P1, NN_DIGIT *Z1, point_t *P2)
{
    NN_DIGIT t1[NUMWORDS];
    NN_DIGIT t2[NUMWORDS];
    NN_DIGIT t3[NUMWORDS];
    NN_DIGIT t4[NUMWORDS];
    NN_DIGIT Z2[NUMWORDS];

    /* P2 == infinity */
    if (NN_Zero(P2->x, NUMWORDS))
    {
        if (NN_Zero(P2->y, NUMWORDS))
        {
            p_copy(P0, P1);
            NN_Assign(Z0, Z1, NUMWORDS);
            return;
        }
    }

    /* P1 == infinity */
    if (NN_Zero(Z1, NUMWORDS))
    {
        p_copy(P0, P2);
        NN_AssignDigit(Z0, 1, NUMWORDS);
        return;
    }

    /* T1 = Z1^2 */
    NN_ModSqrOpt(t1, Z1, param.p, param.omega, NUMWORDS);
    /* T2 = T1*Z1 */
    NN_ModMultOpt(t2, t1, Z1, param.p, param.omega, NUMWORDS);
    /* T1 = T1*P2->x */
    NN_ModMultOpt(t1, t1, P2->x, param.p, param.omega, NUMWORDS);
    /* T2 = T2*P2->y */
    NN_ModMultOpt(t2, t2, P2->y, param.p, param.omega, NUMWORDS);
    /* T1 = T1-P1->x */
    NN_ModSub(t1, t1, P1->x, param.p, NUMWORDS);
    /* T2 = T2-P1->y */
    NN_ModSub(t2, t2, P1->y, param.p, NUMWORDS);

    if (NN_Zero(t1, NUMWORDS))
    {
        if (NN_Zero(t2, NUMWORDS))
        {
            NN_AssignDigit(Z2, 1, NUMWORDS);
            ecc_dbl_proj(P0, Z0, P2, Z2);
            return;
        }
        else
        {
            NN_AssignDigit(Z0, 0, NUMWORDS);
            return;
        }
    }
    /* Z3 = Z1*T1 */
    NN_ModMultOpt(Z0, Z1, t1, param.p, param.omega, NUMWORDS);
    /* T3 = T1^2 */
    NN_ModSqrOpt(t3, t1, param.p, param.omega, NUMWORDS);
    /* T4 = T3*T1 */
    NN_ModMultOpt(t4, t3, t1, param.p, param.omega, NUMWORDS);
    /* T3 = T3*P1->x */
    NN_ModMultOpt(t3, t3, P1->x, param.p, param.omega, NUMWORDS);
    /* T1 = 2*T3 */
    NN_LShift(t1, t3, 1, NUMWORDS);
    NN_ModSmall(t1, param.p, NUMWORDS);
    /* P0->x = T2^2 */
    NN_ModSqrOpt(P0->x, t2, param.p, param.omega, NUMWORDS);
    /* P0->x = P0->x-T1 */
    NN_ModSub(P0->x, P0->x, t1, param.p, NUMWORDS);
    /* P0->x = P0->x-T4 */
    NN_ModSub(P0->x, P0->x, t4, param.p, NUMWORDS);
    /* T3 = T3-P0->x */
    NN_ModSub(t3, t3, P0->x, param.p, NUMWORDS);
    /* T3 = T3*T2 */
    NN_ModMultOpt(t3, t3, t2, param.p, param.omega, NUMWORDS);
    /* T4 = T4*P1->y */
    NN_ModMultOpt(t4, t4, P1->y, param.p, param.omega, NUMWORDS);
    /* P0->y = T3-T4 */
    NN_ModSub(P0->y, t3, t4, param.p, NUMWORDS);

    return;
}

/*---------------------------------------------------------------------------*/
void ecc_init()
{
    /* get parameters */
    get_curve_param(&param);

    /* precompute array for base point */
    ecc_win_precompute(&(param.G), pBaseArray);
}
/*---------------------------------------------------------------------------*/
curve_params_t *
ecc_get_param()
{
    return &param;
}
/*---------------------------------------------------------------------------*/
void ecc_get_order(NN_DIGIT *order)
{
    NN_Assign(order, param.r, NUMWORDS);
}
/*---------------------------------------------------------------------------*/
void ecc_add(point_t *P0, point_t *P1, point_t *P2)
{
    NN_DIGIT Z0[NUMWORDS];
    NN_DIGIT Z1[NUMWORDS];
    NN_DIGIT Z2[NUMWORDS];

    p_clear(P0);
    NN_AssignZero(Z0, NUMWORDS);
    NN_AssignZero(Z1, NUMWORDS);
    NN_AssignZero(Z2, NUMWORDS);
    Z1[0] = 0x01;
    Z2[0] = 0x01;

#ifdef ADD_MIX
    c_add_mix(P0, Z0, P1, Z1, P2);
#else
    ecc_add_proj(P0, Z0, P1, Z1, P2, Z2);
#endif

    if (!Z_is_one(Z0))
    {
        NN_ModInv(Z1, Z0, param.p, NUMWORDS);
        NN_ModMultOpt(Z0, Z1, Z1, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(P0->x, P0->x, Z0, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(Z0, Z0, Z1, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(P0->y, P0->y, Z0, param.p, param.omega, NUMWORDS);
    }
}
/*---------------------------------------------------------------------------*/
void ecc_dbl_proj(point_t *P0, NN_DIGIT *Z0, point_t *P1, NN_DIGIT *Z1)
{
    NN_DIGIT n0[NUMWORDS];
    NN_DIGIT n1[NUMWORDS];
    NN_DIGIT n2[NUMWORDS];
    NN_DIGIT n3[NUMWORDS];

    if (NN_Zero(Z1, NUMWORDS))
    {
        NN_AssignZero(Z0, NUMWORDS);
        return;
    }

    // n1
    if (Z_is_one(Z1))
    {
        /* n1 = 3 * P1->x^2 + param.E.a */
        NN_ModSqrOpt(n0, P1->x, param.p, param.omega, NUMWORDS);
        NN_LShift(n1, n0, 1, NUMWORDS);
        NN_ModSmall(n1, param.p, NUMWORDS);
        NN_ModAdd(n0, n0, n1, param.p, NUMWORDS);
        NN_ModAdd(n1, n0, param.E.a, param.p, NUMWORDS);
    }
    else
    {
        if (param.E.a_minus3)
        {
            /* for a = -3
       * n1 = 3 * (X1 + Z1^2) * (X1 - Z1^2) = 3 * X1^2 - 3 * Z1^4
       */
            NN_ModSqrOpt(n1, Z1, param.p, param.omega, NUMWORDS);
            NN_ModAdd(n0, P1->x, n1, param.p, NUMWORDS);
            NN_ModSub(n2, P1->x, n1, param.p, NUMWORDS);
            NN_ModMultOpt(n1, n0, n2, param.p, param.omega, NUMWORDS);
            NN_LShift(n0, n1, 1, NUMWORDS);
            NN_ModSmall(n0, param.p, NUMWORDS);
            NN_ModAdd(n1, n0, n1, param.p, NUMWORDS);
        }
        else if (param.E.a_zero)
        {
            /* n1 = 3 * P1->x^2 */
            NN_ModSqrOpt(n0, P1->x, param.p, param.omega, NUMWORDS);
            NN_LShift(n1, n0, 1, NUMWORDS);
            NN_ModSmall(n1, param.p, NUMWORDS);
            NN_ModAdd(n1, n0, n1, param.p, NUMWORDS);
        }
        else
        {
            /* n1 = 3 * P1->x^2 + param.E.a * Z1^4 */
            NN_ModSqrOpt(n0, P1->x, param.p, param.omega, NUMWORDS);
            NN_LShift(n1, n0, 1, NUMWORDS);
            NN_ModSmall(n1, param.p, NUMWORDS);
            NN_ModAdd(n0, n0, n1, param.p, NUMWORDS);
            NN_ModSqrOpt(n1, Z1, param.p, param.omega, NUMWORDS);
            NN_ModSqrOpt(n1, n1, param.p, param.omega, NUMWORDS);
            NN_ModMultOpt(n1, n1, param.E.a, param.p, param.omega, NUMWORDS);
            NN_ModAdd(n1, n1, n0, param.p, NUMWORDS);
        }
    }

    /* Z0 = 2 * P1->y * Z1 */
    if (Z_is_one(Z1))
    {
        NN_Assign(n0, P1->y, NUMWORDS);
    }
    else
    {
        NN_ModMultOpt(n0, P1->y, Z1, param.p, param.omega, NUMWORDS);
    }
    NN_LShift(Z0, n0, 1, NUMWORDS);
    NN_ModSmall(Z0, param.p, NUMWORDS);

    /* n2 = 4 * P1->x * P1->y^2 */
    NN_ModSqrOpt(n3, P1->y, param.p, param.omega, NUMWORDS);
    NN_ModMultOpt(n2, P1->x, n3, param.p, param.omega, NUMWORDS);
    NN_LShift(n2, n2, 2, NUMWORDS);
    NN_ModSmall(n2, param.p, NUMWORDS);

    /* P0->x = n1^2 - 2 * n2 */
    NN_LShift(n0, n2, 1, NUMWORDS);
    NN_ModSmall(n0, param.p, NUMWORDS);
    NN_ModSqrOpt(P0->x, n1, param.p, param.omega, NUMWORDS);
    NN_ModSub(P0->x, P0->x, n0, param.p, NUMWORDS);

    /* n3 = 8 * P1->y^4 */
    NN_ModSqrOpt(n0, n3, param.p, param.omega, NUMWORDS);
    NN_LShift(n3, n0, 3, NUMWORDS);
    NN_ModSmall(n3, param.p, NUMWORDS);

    /* P0->y = n1 * (n2 - P0->x) - n3 */
    NN_ModSub(n0, n2, P0->x, param.p, NUMWORDS);
    NN_ModMultOpt(n0, n1, n0, param.p, param.omega, NUMWORDS);
    NN_ModSub(P0->y, n0, n3, param.p, NUMWORDS);
}
/*---------------------------------------------------------------------------*/
void ecc_add_proj(point_t *P0, NN_DIGIT *Z0, point_t *P1, NN_DIGIT *Z1, point_t *P2, NN_DIGIT *Z2)
{
    NN_DIGIT n0[NUMWORDS];
    NN_DIGIT n1[NUMWORDS];
    NN_DIGIT n2[NUMWORDS];
    NN_DIGIT n3[NUMWORDS];
    NN_DIGIT n4[NUMWORDS];
    NN_DIGIT n5[NUMWORDS];
    NN_DIGIT n6[NUMWORDS];

    if (NN_Zero(Z1, NUMWORDS))
    {
        p_copy(P0, P2);
        NN_Assign(Z0, Z2, NUMWORDS);
        return;
    }

    if (NN_Zero(Z2, NUMWORDS))
    {
        p_copy(P0, P1);
        NN_Assign(Z0, Z1, NUMWORDS);
        return;
    }

    /* double */
    if (p_equal(P1, P2))
    {
        ecc_dbl_proj(P0, Z0, P1, Z1);
        return;
    }

    /* add_proj
   * n1, n2
   */
    if (Z_is_one(Z2))
    {
        /* n1 = P1->x, n2 = P1->y */
        NN_Assign(n1, P1->x, NUMWORDS);
        NN_Assign(n2, P1->y, NUMWORDS);
    }
    else
    {
        /* n1 = P1->x * Z2^2 */
        NN_ModSqrOpt(n0, Z2, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(n1, P1->x, n0, param.p, param.omega, NUMWORDS);
        /* n2 = P1->y * Z2^3 */
        NN_ModMultOpt(n0, n0, Z2, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(n2, P1->y, n0, param.p, param.omega, NUMWORDS);
    }

    /* n3, n4 */
    if (Z_is_one(Z1))
    {
        /* n3 = P2->x, n4 = P2->y */
        NN_Assign(n3, P2->x, NUMWORDS);
        NN_Assign(n4, P2->y, NUMWORDS);
    }
    else
    {
        /* n3 = P2->x * Z1^2 */
        NN_ModSqrOpt(n0, Z1, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(n3, P2->x, n0, param.p, param.omega, NUMWORDS);
        /* n4 = P2->y * Z1^3 */
        NN_ModMultOpt(n0, n0, Z1, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(n4, P2->y, n0, param.p, param.omega, NUMWORDS);
    }

    /* n5 = n1 - n3, n6 = n2 - n4 */
    NN_ModSub(n5, n1, n3, param.p, NUMWORDS);
    NN_ModSub(n6, n2, n4, param.p, NUMWORDS);

    if (NN_Zero(n5, NUMWORDS))
    {
        if (NN_Zero(n6, NUMWORDS))
        {
            /* P1 and P2 are same point */
            ecc_dbl_proj(P0, Z0, P1, Z1);
            return;
        }
    }
    else
    {
        /* P1 is the inverse of P2 */
        NN_AssignZero(Z0, NUMWORDS);
        return;
    }

    /* 'n7' = n1 + n3, 'n8' = n2 + n4 */
    NN_ModAdd(n1, n1, n3, param.p, NUMWORDS);
    NN_ModAdd(n2, n2, n4, param.p, NUMWORDS);

    /* Z0 = Z1 * Z2 * n5 */
    if (Z_is_one(Z1) && Z_is_one(Z2))
    {
        NN_Assign(Z0, n5, NUMWORDS);
    }
    else
    {
        if (Z_is_one(Z1))
        {
            NN_Assign(n0, Z2, NUMWORDS);
        }
        else if (Z_is_one(Z2))
        {
            NN_Assign(n0, Z1, NUMWORDS);
        }
        else
        {
            NN_ModMultOpt(n0, Z1, Z2, param.p, param.omega, NUMWORDS);
        }
        NN_ModMultOpt(Z0, n0, n5, param.p, param.omega, NUMWORDS);
    }

    /* P0->x = n6^2 - n5^2 * 'n7' */
    NN_ModSqrOpt(n0, n6, param.p, param.omega, NUMWORDS);
    NN_ModSqrOpt(n4, n5, param.p, param.omega, NUMWORDS);
    NN_ModMultOpt(n3, n1, n4, param.p, param.omega, NUMWORDS);
    NN_ModSub(P0->x, n0, n3, param.p, NUMWORDS);

    /* 'n9' = n5^2 * 'n7' - 2 * P0->x */
    NN_LShift(n0, P0->x, 1, NUMWORDS);
    NN_ModSmall(n0, param.p, NUMWORDS);
    NN_ModSub(n0, n3, n0, param.p, NUMWORDS);

    /* P0->y = (n6 * 'n9' - 'n8' * 'n5^3') / 2 */
    NN_ModMultOpt(n0, n0, n6, param.p, param.omega, NUMWORDS);
    NN_ModMultOpt(n5, n4, n5, param.p, param.omega, NUMWORDS);
    NN_ModMultOpt(n1, n2, n5, param.p, param.omega, NUMWORDS);
    NN_ModSub(n0, n0, n1, param.p, NUMWORDS);

    if ((n0[0] % 2) == 1)
    {
        NN_Add(n0, n0, param.p, NUMWORDS);
    }

    NN_RShift(P0->y, n0, 1, NUMWORDS);
}
/*---------------------------------------------------------------------------*/
void ecc_win_precompute(point_t *baseP, point_t *pointArray)
{
    uint8_t i;

    NN_Assign(pointArray[0].x, baseP->x, NUMWORDS);
    NN_Assign(pointArray[0].y, baseP->y, NUMWORDS);

    for (i = 1; i < NUM_POINTS; i++)
    {
        ecc_add(&(pointArray[i]), &(pointArray[i - 1]), baseP);
    }

    for (i = 0; i < NUM_MASKS; i++)
    {
        mask[i] = BASIC_MASK << (W_BITS * i);
    }
}
/*---------------------------------------------------------------------------*/
void ecc_mul(point_t *P0, point_t *P1, NN_DIGIT *n)
{
    int16_t i, tmp;
    NN_DIGIT Z0[NUMWORDS];
    NN_DIGIT Z1[NUMWORDS];

    /* clear point */
    p_clear(P0);

    /* convert to Jprojective coordinate */
    NN_AssignZero(Z0, NUMWORDS);
    NN_AssignZero(Z1, NUMWORDS);
    Z1[0] = 0x01;

    tmp = NN_Bits(n, NUMWORDS);

    for (i = tmp - 1; i >= 0; i--)
    {
        ecc_dbl_proj(P0, Z0, P0, Z0);

        if (b_testbit(n, i))
        {

#ifdef ADD_MIX
            c_add_mix(P0, Z0, P0, Z0, P1);
#else
            ecc_add_proj(P0, Z0, P0, Z0, P1, Z1);
#endif
        }
    }
    /* convert back to affine coordinate */
    if (!Z_is_one(Z0))
    {
        NN_ModInv(Z1, Z0, param.p, NUMWORDS);
        NN_ModMultOpt(Z0, Z1, Z1, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(P0->x, P0->x, Z0, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(Z0, Z0, Z1, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(P0->y, P0->y, Z0, param.p, param.omega, NUMWORDS);
    }
}
/*---------------------------------------------------------------------------*/
void ecc_m_dbl_projective(point_t *P0, NN_DIGIT *Z0, uint8_t m)
{
    uint8_t i;
    NN_DIGIT W[NUMWORDS];
    NN_DIGIT A[NUMWORDS];
    NN_DIGIT B[NUMWORDS];
    NN_DIGIT t1[NUMWORDS];
    NN_DIGIT y2[NUMWORDS];

    if (NN_Zero(Z0, NUMWORDS))
    {
        return;
    }

    /* P0->y = 2*P0->y */
    NN_LShift(P0->y, P0->y, 1, NUMWORDS);
    NN_ModSmall(P0->y, param.p, NUMWORDS);
    /* W = Z^4 */
    NN_ModSqrOpt(W, Z0, param.p, param.omega, NUMWORDS);
    NN_ModSqrOpt(W, W, param.p, param.omega, NUMWORDS);

    for (i = 0; i < m; i++)
    {
        if (param.E.a_minus3)
        {
            /* A = 3(X^2-W) */
            NN_ModSqrOpt(A, P0->x, param.p, param.omega, NUMWORDS);
            NN_ModSub(A, A, W, param.p, NUMWORDS);
            NN_LShift(t1, A, 1, NUMWORDS);
            NN_ModSmall(t1, param.p, NUMWORDS);
            NN_ModAdd(A, A, t1, param.p, NUMWORDS);
        }
        else if (param.E.a_zero)
        {
            /* A = 3*X^2 */
            NN_ModSqrOpt(t1, P0->x, param.p, param.omega, NUMWORDS);
            NN_LShift(A, t1, 1, NUMWORDS);
            NN_ModSmall(A, param.p, NUMWORDS);
            NN_ModAdd(A, A, t1, param.p, NUMWORDS);
        }
        else
        {
            /* A = 3*X^2 + a*W */
            NN_ModSqrOpt(t1, P0->x, param.p, param.omega, NUMWORDS);
            NN_LShift(A, t1, 1, NUMWORDS);
            NN_ModSmall(A, param.p, NUMWORDS);
            NN_ModAdd(A, A, t1, param.p, NUMWORDS);
            NN_ModMultOpt(t1, param.E.a, W, param.p, param.omega, NUMWORDS);
            NN_ModAdd(A, A, t1, param.p, NUMWORDS);
        }
        /* B = X*Y^2 */
        NN_ModSqrOpt(y2, P0->y, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(B, P0->x, y2, param.p, param.omega, NUMWORDS);
        /* X = A^2 - 2B */
        NN_ModSqrOpt(P0->x, A, param.p, param.omega, NUMWORDS);
        NN_LShift(t1, B, 1, NUMWORDS);
        NN_ModSmall(t1, param.p, NUMWORDS);
        NN_ModSub(P0->x, P0->x, t1, param.p, NUMWORDS);
        /* Z = Z*Y */
        NN_ModMultOpt(Z0, Z0, P0->y, param.p, param.omega, NUMWORDS);
        NN_ModSqrOpt(y2, y2, param.p, param.omega, NUMWORDS);
        if (i < m - 1)
        {
            /* W = W*Y^4 */
            NN_ModMultOpt(W, W, y2, param.p, param.omega, NUMWORDS);
        }
        /* Y = 2A(B-X)-Y^4 */
        NN_LShift(A, A, 1, NUMWORDS);
        NN_ModSmall(A, param.p, NUMWORDS);
        NN_ModSub(B, B, P0->x, param.p, NUMWORDS);
        NN_ModMultOpt(A, A, B, param.p, param.omega, NUMWORDS);
        NN_ModSub(P0->y, A, y2, param.p, NUMWORDS);
    }
    if ((P0->y[0] % 2) == 1)
    {
        NN_Add(P0->y, P0->y, param.p, NUMWORDS);
    }
    NN_RShift(P0->y, P0->y, 1, NUMWORDS);
}

/*---------------------------------------------------------------------------*/
/*
 * scalar point multiplication
 * P0 = n*basepoint
 * pointArray is array of basepoint, pointArray[0] = basepoint, pointArray[1] = 2*basepoint ...
 */
void ecc_win_mul(point_t *P0, NN_DIGIT *n, point_t *pointArray)
{

    int16_t i, tmp;
    int8_t j;
    NN_DIGIT windex;
    NN_DIGIT Z0[NUMWORDS];
    NN_DIGIT Z1[NUMWORDS];
#ifndef REPEAT_DOUBLE
    int8_t k;
#endif

    p_clear(P0);

    /* Convert to Jprojective coordinate */
    NN_AssignZero(Z0, NUMWORDS);
    NN_AssignZero(Z1, NUMWORDS);
    Z1[0] = 0x01;

    tmp = NN_Digits(n, NUMWORDS);

    for (i = tmp - 1; i >= 0; i--)
    {
        for (j = NN_DIGIT_BITS / W_BITS - 1; j >= 0; j--)
        {

#ifndef REPEAT_DOUBLE
            for (k = 0; k < W_BITS; k++)
            {
                ecc_dbl_proj(P0, Z0, P0, Z0);
            }
#else
            ecc_m_dbl_projective(P0, Z0, W_BITS);
#endif

            windex = mask[j] & n[i];

            if (windex)
            {
                windex = windex >> (j * W_BITS);

#ifdef ADD_MIX
                c_add_mix(P0, Z0, P0, Z0, &(pointArray[windex - 1]));
#else
                ecc_add_proj(P0, Z0, P0, Z0, &(pointArray[windex - 1]), Z1);
#endif
            }
        }
    }

    /* Convert back to affine coordinate */
    if (!Z_is_one(Z0))
    {
        NN_ModInv(Z1, Z0, param.p, NUMWORDS);
        NN_ModMultOpt(Z0, Z1, Z1, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(P0->x, P0->x, Z0, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(Z0, Z0, Z1, param.p, param.omega, NUMWORDS);
        NN_ModMultOpt(P0->y, P0->y, Z0, param.p, param.omega, NUMWORDS);
    }
}

/*---------------------------------------------------------------------------*/
void ecc_win_mul_base(point_t *P0, NN_DIGIT *n)
{
    ecc_win_mul(P0, n, pBaseArray);
}
/*---------------------------------------------------------------------------*/
point_t *
ecc_get_base_p()
{
    return &(param.G);
}
/*---------------------------------------------------------------------------*/
void ecc_gen_pub_key(NN_DIGIT *priv_key, point_t *pub)
{
    ecc_win_mul(pub, priv_key, pBaseArray);
}
/*---------------------------------------------------------------------------*/
void ecc_gen_private_key(NN_DIGIT *PrivateKey)
{
    NN_UINT order_digit_len;
    NN_UINT order_bit_len;
    char done = FALSE;
    uint8_t ri;
    NN_DIGIT digit_mask;

    order_bit_len = NN_Bits(param.r, NUMWORDS);
    order_digit_len = NN_Digits(param.r, NUMWORDS);

    while (!done)
    {
        prng((uint8_t *)PrivateKey, order_digit_len * sizeof(NN_DIGIT));

        for (ri = order_digit_len; ri < NUMWORDS; ri++)
        {
            PrivateKey[ri] = 0;
        }

        if (order_bit_len % NN_DIGIT_BITS != 0)
        {
            digit_mask = MAX_NN_DIGIT >> (NN_DIGIT_BITS - order_bit_len % NN_DIGIT_BITS);
            PrivateKey[order_digit_len - 1] = PrivateKey[order_digit_len - 1] & digit_mask;
        }
        NN_ModSmall(PrivateKey, param.r, NUMWORDS);

        if (NN_Zero(PrivateKey, NUMWORDS) != 1)
        {
            done = TRUE;
        }
    }
}

// AUTOGENERATED, DO NOT EDIT. See CONTRIBUTING.md for instructions.
// Also know as prime256v1 aka NIST P-256
#include "ecc.h"

#define TRUE 1
#define FALSE 0

void get_curve_param(curve_params_t *para)
{
#ifdef EIGHT_BIT_PROCESSOR
    memset(para->p, 0, NUMWORDS * NN_DIGIT_LEN);
    para->p[31] = 0xFF;
    para->p[30] = 0xFF;
    para->p[29] = 0xFF;
    para->p[28] = 0xFF;
    para->p[27] = 0x00;
    para->p[26] = 0x00;
    para->p[25] = 0x00;
    para->p[24] = 0x01;
    para->p[23] = 0x00;
    para->p[22] = 0x00;
    para->p[21] = 0x00;
    para->p[20] = 0x00;
    para->p[19] = 0x00;
    para->p[18] = 0x00;
    para->p[17] = 0x00;
    para->p[16] = 0x00;
    para->p[15] = 0x00;
    para->p[14] = 0x00;
    para->p[13] = 0x00;
    para->p[12] = 0x00;
    para->p[11] = 0xFF;
    para->p[10] = 0xFF;
    para->p[9] = 0xFF;
    para->p[8] = 0xFF;
    para->p[7] = 0xFF;
    para->p[6] = 0xFF;
    para->p[5] = 0xFF;
    para->p[4] = 0xFF;
    para->p[3] = 0xFF;
    para->p[2] = 0xFF;
    para->p[1] = 0xFF;
    para->p[0] = 0xFF;

    memset(para->omega, 0, NUMWORDS * NN_DIGIT_LEN);
    para->omega[27] = 0xFF;
    para->omega[26] = 0xFF;
    para->omega[25] = 0xFF;
    para->omega[24] = 0xFE;
    para->omega[23] = 0xFF;
    para->omega[22] = 0xFF;
    para->omega[21] = 0xFF;
    para->omega[20] = 0xFF;
    para->omega[19] = 0xFF;
    para->omega[18] = 0xFF;
    para->omega[17] = 0xFF;
    para->omega[16] = 0xFF;
    para->omega[15] = 0xFF;
    para->omega[14] = 0xFF;
    para->omega[13] = 0xFF;
    para->omega[12] = 0xFF;
    para->omega[11] = 0x00;
    para->omega[10] = 0x00;
    para->omega[9] = 0x00;
    para->omega[8] = 0x00;
    para->omega[7] = 0x00;
    para->omega[6] = 0x00;
    para->omega[5] = 0x00;
    para->omega[4] = 0x00;
    para->omega[3] = 0x00;
    para->omega[2] = 0x00;
    para->omega[1] = 0x00;
    para->omega[0] = 0x01;
    // curve that will be used
    // a = -3
    memset(para->E.a, 0, NUMWORDS * NN_DIGIT_LEN);
    para->E.a[31] = 0xFF;
    para->E.a[30] = 0xFF;
    para->E.a[29] = 0xFF;
    para->E.a[28] = 0xFF;
    para->E.a[27] = 0x00;
    para->E.a[26] = 0x00;
    para->E.a[25] = 0x00;
    para->E.a[24] = 0x01;
    para->E.a[23] = 0x00;
    para->E.a[22] = 0x00;
    para->E.a[21] = 0x00;
    para->E.a[20] = 0x00;
    para->E.a[19] = 0x00;
    para->E.a[18] = 0x00;
    para->E.a[17] = 0x00;
    para->E.a[16] = 0x00;
    para->E.a[15] = 0x00;
    para->E.a[14] = 0x00;
    para->E.a[13] = 0x00;
    para->E.a[12] = 0x00;
    para->E.a[11] = 0xFF;
    para->E.a[10] = 0xFF;
    para->E.a[9] = 0xFF;
    para->E.a[8] = 0xFF;
    para->E.a[7] = 0xFF;
    para->E.a[6] = 0xFF;
    para->E.a[5] = 0xFF;
    para->E.a[4] = 0xFF;
    para->E.a[3] = 0xFF;
    para->E.a[2] = 0xFF;
    para->E.a[1] = 0xFF;
    para->E.a[0] = 0xFC;

    para->E.a_minus3 = TRUE;
    para->E.a_zero = FALSE;

    // b = 7
    memset(para->E.b, 0, NUMWORDS * NN_DIGIT_LEN);
    para->G.x[31] = 0x5A;
    para->G.x[30] = 0xC6;
    para->G.x[29] = 0x35;
    para->G.x[28] = 0xD8;
    para->G.x[27] = 0xAA;
    para->G.x[26] = 0x3A;
    para->G.x[25] = 0x93;
    para->G.x[24] = 0xE7;
    para->G.x[23] = 0xB3;
    para->G.x[22] = 0xEB;
    para->G.x[21] = 0xBD;
    para->G.x[20] = 0x55;
    para->G.x[19] = 0x76;
    para->G.x[18] = 0x98;
    para->G.x[17] = 0x86;
    para->G.x[16] = 0xBC;
    para->G.x[15] = 0x65;
    para->G.x[14] = 0x1D;
    para->G.x[13] = 0x06;
    para->G.x[12] = 0xB0;
    para->G.x[11] = 0xCC;
    para->G.x[10] = 0x53;
    para->G.x[9] = 0xB0;
    para->G.x[8] = 0xF6;
    para->G.x[7] = 0x3B;
    para->G.x[6] = 0xCE;
    para->G.x[5] = 0x3C;
    para->G.x[4] = 0x3E;
    para->G.x[3] = 0x27;
    para->G.x[2] = 0xD2;
    para->G.x[1] = 0x60;
    para->G.x[0] = 0x4B;

    // base point
    memset(para->G.x, 0, NUMWORDS * NN_DIGIT_LEN);
    para->G.x[31] = 0x6B;
    para->G.x[30] = 0x17;
    para->G.x[29] = 0xD1;
    para->G.x[28] = 0xF2;
    para->G.x[27] = 0xE1;
    para->G.x[26] = 0x2C;
    para->G.x[25] = 0x42;
    para->G.x[24] = 0x47;
    para->G.x[23] = 0xF8;
    para->G.x[22] = 0xBC;
    para->G.x[21] = 0xE6;
    para->G.x[20] = 0xE5;
    para->G.x[19] = 0x63;
    para->G.x[18] = 0xA4;
    para->G.x[17] = 0x40;
    para->G.x[16] = 0xF2;
    para->G.x[15] = 0x77;
    para->G.x[14] = 0x03;
    para->G.x[13] = 0x7D;
    para->G.x[12] = 0x81;
    para->G.x[11] = 0x2D;
    para->G.x[10] = 0xEB;
    para->G.x[9] = 0x33;
    para->G.x[8] = 0xA0;
    para->G.x[7] = 0xF4;
    para->G.x[6] = 0xA1;
    para->G.x[5] = 0x39;
    para->G.x[4] = 0x45;
    para->G.x[3] = 0xD8;
    para->G.x[2] = 0x98;
    para->G.x[1] = 0xC2;
    para->G.x[0] = 0x96;

    memset(para->G.y, 0, NUMWORDS * NN_DIGIT_LEN);
    para->G.y[31] = 0x4F;
    para->G.y[30] = 0xE3;
    para->G.y[29] = 0x42;
    para->G.y[28] = 0xE2;
    para->G.y[27] = 0xFE;
    para->G.y[26] = 0x1A;
    para->G.y[25] = 0x7F;
    para->G.y[24] = 0x9B;
    para->G.y[23] = 0x8E;
    para->G.y[22] = 0xE7;
    para->G.y[21] = 0xEB;
    para->G.y[20] = 0x4A;
    para->G.y[19] = 0x7C;
    para->G.y[18] = 0x0F;
    para->G.y[17] = 0x9E;
    para->G.y[16] = 0x16;
    para->G.y[15] = 0x2B;
    para->G.y[14] = 0xCE;
    para->G.y[13] = 0x33;
    para->G.y[12] = 0x57;
    para->G.y[11] = 0x6B;
    para->G.y[10] = 0x31;
    para->G.y[9] = 0x5E;
    para->G.y[8] = 0xCE;
    para->G.y[7] = 0xCB;
    para->G.y[6] = 0xB6;
    para->G.y[5] = 0x40;
    para->G.y[4] = 0x68;
    para->G.y[3] = 0x37;
    para->G.y[2] = 0xBF;
    para->G.y[1] = 0x51;
    para->G.y[0] = 0xF5;

    // prime divide the number of points
    memset(para->r, 0, NUMWORDS * NN_DIGIT_LEN);
    para->r[31] = 0xFF;
    para->r[30] = 0xFF;
    para->r[29] = 0xFF;
    para->r[28] = 0xFF;
    para->r[27] = 0x00;
    para->r[26] = 0x00;
    para->r[25] = 0x00;
    para->r[24] = 0x00;
    para->r[23] = 0xFF;
    para->r[22] = 0xFF;
    para->r[21] = 0xFF;
    para->r[20] = 0xFF;
    para->r[19] = 0xFF;
    para->r[18] = 0xFF;
    para->r[17] = 0xFF;
    para->r[16] = 0xFF;
    para->r[15] = 0xBC;
    para->r[14] = 0xE6;
    para->r[13] = 0xFA;
    para->r[12] = 0xAD;
    para->r[11] = 0xA7;
    para->r[10] = 0x17;
    para->r[9] = 0x9E;
    para->r[8] = 0x84;
    para->r[7] = 0xF3;
    para->r[6] = 0xB9;
    para->r[5] = 0xCA;
    para->r[4] = 0xC2;
    para->r[3] = 0xFC;
    para->r[2] = 0x63;
    para->r[1] = 0x25;
    para->r[0] = 0x51;
    /* EIGHT_BIT_PROCESSOR */
#elif defined(SIXTEEN_BIT_PROCESSOR)
    memset(para->p, 0, NUMWORDS * NN_DIGIT_LEN);
    para->p[15] = 0xFFFF;
    para->p[14] = 0xFFFF;
    para->p[13] = 0x0000;
    para->p[12] = 0x0001;
    para->p[11] = 0x0000;
    para->p[10] = 0x0000;
    para->p[9] = 0x0000;
    para->p[8] = 0x0000;
    para->p[7] = 0x0000;
    para->p[6] = 0x0000;
    para->p[5] = 0xFFFF;
    para->p[4] = 0xFFFF;
    para->p[3] = 0xFFFF;
    para->p[2] = 0xFFFF;
    para->p[1] = 0xFFFF;
    para->p[0] = 0xFFFF;

    memset(para->omega, 0, NUMWORDS * NN_DIGIT_LEN);
    para->omega[13] = 0xFFFF;
    para->omega[12] = 0xFFFE;
    para->omega[11] = 0xFFFF;
    para->omega[10] = 0xFFFF;
    para->omega[9] = 0xFFFF;
    para->omega[8] = 0xFFFF;
    para->omega[7] = 0xFFFF;
    para->omega[6] = 0xFFFF;
    para->omega[5] = 0x0000;
    para->omega[4] = 0x0000;
    para->omega[3] = 0x0000;
    para->omega[2] = 0x0000;
    para->omega[1] = 0x0000;
    para->omega[0] = 0x0001;
    // curve that will be used
    // a = -3
    memset(para->E.a, 0, NUMWORDS * NN_DIGIT_LEN);
    para->E.a[15] = 0xFFFF;
    para->E.a[14] = 0xFFFF;
    para->E.a[13] = 0x0000;
    para->E.a[12] = 0x0001;
    para->E.a[11] = 0x0000;
    para->E.a[10] = 0x0000;
    para->E.a[9] = 0x0000;
    para->E.a[8] = 0x0000;
    para->E.a[7] = 0x0000;
    para->E.a[6] = 0x0000;
    para->E.a[5] = 0xFFFF;
    para->E.a[4] = 0xFFFF;
    para->E.a[3] = 0xFFFF;
    para->E.a[2] = 0xFFFF;
    para->E.a[1] = 0xFFFF;
    para->E.a[0] = 0xFFFC;

    para->E.a_minus3 = TRUE;
    para->E.a_zero = FALSE;

    // b = 7
    memset(para->E.b, 0, NUMWORDS * NN_DIGIT_LEN);
    para->G.x[15] = 0x5AC6;
    para->G.x[14] = 0x35D8;
    para->G.x[13] = 0xAA3A;
    para->G.x[12] = 0x93E7;
    para->G.x[11] = 0xB3EB;
    para->G.x[10] = 0xBD55;
    para->G.x[9] = 0x7698;
    para->G.x[8] = 0x86BC;
    para->G.x[7] = 0x651D;
    para->G.x[6] = 0x06B0;
    para->G.x[5] = 0xCC53;
    para->G.x[4] = 0xB0F6;
    para->G.x[3] = 0x3BCE;
    para->G.x[2] = 0x3C3E;
    para->G.x[1] = 0x27D2;
    para->G.x[0] = 0x604B;

    // base point
    memset(para->G.x, 0, NUMWORDS * NN_DIGIT_LEN);
    para->G.x[15] = 0x6B17;
    para->G.x[14] = 0xD1F2;
    para->G.x[13] = 0xE12C;
    para->G.x[12] = 0x4247;
    para->G.x[11] = 0xF8BC;
    para->G.x[10] = 0xE6E5;
    para->G.x[9] = 0x63A4;
    para->G.x[8] = 0x40F2;
    para->G.x[7] = 0x7703;
    para->G.x[6] = 0x7D81;
    para->G.x[5] = 0x2DEB;
    para->G.x[4] = 0x33A0;
    para->G.x[3] = 0xF4A1;
    para->G.x[2] = 0x3945;
    para->G.x[1] = 0xD898;
    para->G.x[0] = 0xC296;

    memset(para->G.y, 0, NUMWORDS * NN_DIGIT_LEN);
    para->G.y[15] = 0x4FE3;
    para->G.y[14] = 0x42E2;
    para->G.y[13] = 0xFE1A;
    para->G.y[12] = 0x7F9B;
    para->G.y[11] = 0x8EE7;
    para->G.y[10] = 0xEB4A;
    para->G.y[9] = 0x7C0F;
    para->G.y[8] = 0x9E16;
    para->G.y[7] = 0x2BCE;
    para->G.y[6] = 0x3357;
    para->G.y[5] = 0x6B31;
    para->G.y[4] = 0x5ECE;
    para->G.y[3] = 0xCBB6;
    para->G.y[2] = 0x4068;
    para->G.y[1] = 0x37BF;
    para->G.y[0] = 0x51F5;

    // prime divide the number of points
    memset(para->r, 0, NUMWORDS * NN_DIGIT_LEN);
    para->r[15] = 0xFFFF;
    para->r[14] = 0xFFFF;
    para->r[13] = 0x0000;
    para->r[12] = 0x0000;
    para->r[11] = 0xFFFF;
    para->r[10] = 0xFFFF;
    para->r[9] = 0xFFFF;
    para->r[8] = 0xFFFF;
    para->r[7] = 0xBCE6;
    para->r[6] = 0xFAAD;
    para->r[5] = 0xA717;
    para->r[4] = 0x9E84;
    para->r[3] = 0xF3B9;
    para->r[2] = 0xCAC2;
    para->r[1] = 0xFC63;
    para->r[0] = 0x2551;

    /* SIXTEEN_BIT_PROCESSOR */
#elif defined(THIRTYTWO_BIT_PROCESSOR)
    // init parameters

    memset(para->p, 0, NUMWORDS * NN_DIGIT_LEN);
    para->p[7] = 0xFFFFFFFF;
    para->p[6] = 0x00000001;
    para->p[5] = 0x00000000;
    para->p[4] = 0x00000000;
    para->p[3] = 0x00000000;
    para->p[2] = 0xFFFFFFFF;
    para->p[1] = 0xFFFFFFFF;
    para->p[0] = 0xFFFFFFFF;

    memset(para->omega, 0, NUMWORDS * NN_DIGIT_LEN);
    para->omega[6] = 0xFFFFFFFE;
    para->omega[5] = 0xFFFFFFFF;
    para->omega[4] = 0xFFFFFFFF;
    para->omega[3] = 0xFFFFFFFF;
    para->omega[2] = 0x00000000;
    para->omega[1] = 0x00000000;
    para->omega[0] = 0x00000001;
    // curve that will be used
    // a = -3
    memset(para->E.a, 0, NUMWORDS * NN_DIGIT_LEN);
    para->E.a[7] = 0xFFFFFFFF;
    para->E.a[6] = 0x00000001;
    para->E.a[5] = 0x00000000;
    para->E.a[4] = 0x00000000;
    para->E.a[3] = 0x00000000;
    para->E.a[2] = 0xFFFFFFFF;
    para->E.a[1] = 0xFFFFFFFF;
    para->E.a[0] = 0xFFFFFFFC;

    para->E.a_minus3 = TRUE;
    para->E.a_zero = FALSE;

    // b = 7
    memset(para->E.b, 0, NUMWORDS * NN_DIGIT_LEN);
    para->G.x[7] = 0x5AC635D8;
    para->G.x[6] = 0xAA3A93E7;
    para->G.x[5] = 0xB3EBBD55;
    para->G.x[4] = 0x769886BC;
    para->G.x[3] = 0x651D06B0;
    para->G.x[2] = 0xCC53B0F6;
    para->G.x[1] = 0x3BCE3C3E;
    para->G.x[0] = 0x27D2604B;

    // base point
    memset(para->G.x, 0, NUMWORDS * NN_DIGIT_LEN);
    para->G.x[7] = 0x6B17D1F2;
    para->G.x[6] = 0xE12C4247;
    para->G.x[5] = 0xF8BCE6E5;
    para->G.x[4] = 0x63A440F2;
    para->G.x[3] = 0x77037D81;
    para->G.x[2] = 0x2DEB33A0;
    para->G.x[1] = 0xF4A13945;
    para->G.x[0] = 0xD898C296;

    memset(para->G.y, 0, NUMWORDS * NN_DIGIT_LEN);
    para->G.y[7] = 0x4FE342E2;
    para->G.y[6] = 0xFE1A7F9B;
    para->G.y[5] = 0x8EE7EB4A;
    para->G.y[4] = 0x7C0F9E16;
    para->G.y[3] = 0x2BCE3357;
    para->G.y[2] = 0x6B315ECE;
    para->G.y[1] = 0xCBB64068;
    para->G.y[0] = 0x37BF51F5;

    // prime divide the number of points
    memset(para->r, 0, NUMWORDS * NN_DIGIT_LEN);
    para->r[7] = 0xFFFFFFFF;
    para->r[6] = 0x00000000;
    para->r[5] = 0xFFFFFFFF;
    para->r[4] = 0xFFFFFFFF;
    para->r[3] = 0xBCE6FAAD;
    para->r[2] = 0xA7179E84;
    para->r[1] = 0xF3B9CAC2;
    para->r[0] = 0xFC632551;

#endif /* THIRTYTWO_BIT_PROCESSOR */
}

NN_UINT omega_mul(NN_DIGIT *a, NN_DIGIT *b, NN_DIGIT *omega, NN_UINT digits)
{
#ifdef EIGHT_BIT_PROCESSOR
    int omega_digit_length = 28;
#elif defined(SIXTEEN_BIT_PROCESSOR)
    int omega_digit_length = 14;
#elif defined(THIRTYTWO_BIT_PROCESSOR)
    int omega_digit_length = 7;
#endif

    NN_Mult(a, b, omega,
            digits > omega_digit_length ? digits : omega_digit_length);
    return digits + omega_digit_length;
}
